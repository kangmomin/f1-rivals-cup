
### 1. DB 스키마 재설계 (RBAC Model)

기존 `users.role` 컬럼을 삭제하고, 3단계 구조(User - Role - Permission)로 분리합니다.

#### 1.1. 테이블 정의 (DDL)

```sql
-- 1. 권한 (Permissions): 가장 작은 단위의 행동 (예: 'news.create', 'fund.manage')
CREATE TABLE permissions (
    id SERIAL PRIMARY KEY,
    code VARCHAR(50) NOT NULL UNIQUE, -- 코드 레벨에서 체크할 문자열
    description TEXT
);

-- 2. 역할 (Roles): 권한들의 집합 (예: 'Director', 'Press')
CREATE TABLE roles (
    id SERIAL PRIMARY KEY,
    name VARCHAR(30) NOT NULL UNIQUE
);

-- 3. 역할-권한 매핑 (Role-Permission): M:N 관계
CREATE TABLE role_permissions (
    role_id INT NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    permission_id INT NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id)
);

-- 4. 유저-역할 매핑 (User-Role): 유저에게 역할 부여 (한 유저가 여러 역할 가능)
CREATE TABLE user_roles (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id INT NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, role_id)
);

```

---

### 2. 조회 최적화 (Optimization)

권한 체크는 **모든 API 요청마다** 발생하므로 가장 가벼워야 합니다. 4개의 테이블을 매번 조인하는 것은 비효율적일 수 있습니다. 이를 해결하기 위한 **View**와 **Index** 전략입니다.

#### 2.1. 인덱스 전략 (Indexing)

PostgreSQL의 Query Planner가 조인을 가장 빠르게 수행할 수 있도록 FK 컬럼에 인덱스를 겁니다. (PK는 자동 인덱싱됨)

```sql
-- user_roles 테이블의 user_id 조회 속도 향상 (로그인 시 빈번하게 조회됨)
CREATE INDEX idx_user_roles_user_id ON user_roles(user_id);

-- role_permissions 테이블의 조인 속도 향상
CREATE INDEX idx_role_permissions_role_id ON role_permissions(role_id);

```

#### 2.2. 권한 조회 뷰 (Flattened View)

매번 복잡한 조인 쿼리를 작성하는 대신, **"특정 유저가 가진 모든 권한 코드"**를 바로 조회할 수 있는 뷰를 생성합니다. `sqlc`는 이 뷰를 기반으로 Go 코드를 생성해 주므로 사용이 매우 편해집니다.

```sql
CREATE OR REPLACE VIEW v_user_permissions AS
SELECT DISTINCT
    ur.user_id,
    p.code AS permission_code
FROM
    user_roles ur
JOIN
    role_permissions rp ON ur.role_id = rp.role_id
JOIN
    permissions p ON rp.permission_id = p.id;

```

* `DISTINCT`: 유저가 여러 역할을 가지고 있고, 그 역할들이 겹치는 권한을 가지고 있어도 중복된 권한 코드는 하나만 나오게 합니다.

---

### 3. 적용 예시 (Data & Usage)

#### 3.1. 데이터 예시 (Seed Data)

| Role | Permissions (code) |
| --- | --- |
| **Director** (감독) | `team.manage` (팀 관리), `fund.read` (자금 조회), `trade.offer` (이적 제안) |
| **Press** (기자) | `news.create` (기사 작성), `news.publish` (기사 발행) |
| **Admin** (관리자) | `*` (모든 권한 - 로직에서 처리) |

#### 3.2. sqlc 쿼리 작성 (Go 코드 생성용)

이제 Go 백엔드에서는 복잡한 로직 없이 이 뷰만 조회하면 됩니다.

```sql
-- name: GetUserPermissions :many
-- 유저 ID로 해당 유저가 가진 모든 권한 코드를 조회합니다.
SELECT permission_code
FROM v_user_permissions
WHERE user_id = $1;

-- name: HasPermission :one
-- 유저가 특정 권한을 가지고 있는지 확인합니다 (Boolean 반환).
SELECT EXISTS (
    SELECT 1
    FROM v_user_permissions
    WHERE user_id = $1 AND permission_code = $2
);

```

#### 3.3. Go (Echo Middleware) 활용 예시

```go
// Middleware에서 권한 체크
func RequirePermission(permCode string) echo.MiddlewareFunc {
    return func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            userID := c.Get("user_id").(uuid.UUID)

            // sqlc로 생성된 쿼리 사용 (매우 빠름)
            hasPerm, err := query.HasPermission(c.Request().Context(), db.HasPermissionParams{
                UserID: userID,
                PermissionCode: permCode,
            })

            if err != nil || !hasPerm {
                return echo.ErrForbidden // 403 Forbidden
            }
            return next(c)
        }
    }
}

// 라우터 적용
e.POST("/news", handler.CreateNews, RequirePermission("news.create"))
e.POST("/teams/budget", handler.ManageBudget, RequirePermission("fund.manage"))

```

---